MODULE BASIC
 	IMPLICIT NONE 
 	TYPE :: H_BCT
 		INTEGER :: DEG
 		REAL (KIND = 8), ALLOCATABLE :: H_COE(:)
 	END TYPE H_BCT
 	INTEGER :: NCYC,NCYC_OUT,NCYC_CHECK
 	INTEGER :: OUT_TYPE ! CONTROL THE OUTPUT TYPE (= 0, NORMAL CONSTANT STEP OUTPUT; ~= 0, USING THE OUTPUT VECTOR)
 	REAL (KIND = 8), ALLOCATABLE, DIMENSION (:) :: OUTPUT_VEC  ! (THE SIZE OF OUTPUT_VEC IS OUT_TYPE)
	INTEGER :: UIT,SOIL_TOTAL
!-------For the Boundary Conditions
	INTEGER :: WELL_NUM
	INTEGER, ALLOCATABLE :: WELL_CELL_NUM(:)
	REAL (KIND = 8), ALLOCATABLE, DIMENSION (:) :: QWELL,WELL_X,WELL_Y
	INTEGER :: HEAD_NUM  ! Numbers of Head Boundary Conditions
	TYPE (H_BCT), ALLOCATABLE :: H_INPUT(:)
	INTEGER :: FLUX_NUM  ! NUmbers of Flux Boundary Conditions
	REAL (KIND = 8), ALLOCATABLE, DIMENSION (:) :: QBX,QBY
	INTEGER :: RAIN_NUM   ! Numbers of rainfall bc
	REAL (KIND = 8), ALLOCATABLE, DIMENSION (:) :: Q_RAIN  ! RAINFALL CONDITION
	INTEGER :: RIVER_NUM 
	REAL (KIND = 8), ALLOCATABLE, DIMENSION (:) :: RIVER_HEAD,RIVER_BED,RIVER_THICKNESS !,RIVER_AREA ! River area is not needed here but we still keep that for future use.
!-------For basis parameters
	REAL (KIND = 8) :: T,DT,ZX,ERRO,ERROX2,T_START
	REAL (KIND = 8) :: DT_AMP,T_LIM
	INTEGER :: INTER_CONTROL,K_SCHEME
!-------For the output of the results from the monitoring wells
	INTEGER :: DRAW_NUM
	INTEGER, ALLOCATABLE, DIMENSION (:) :: DRAW_XYZ
!-------Name for I/O Files
	CHARACTER (LEN = 256) :: NAME1,NAME2,NAME3,NAME4,NAME5,NAME6,NAME_FILE
	REAL (KIND = 8) :: PICARD_REL
!--------For element and face 
	INTEGER :: CELL_TOT,FACE_TOT,NODE_TOT,XYZ_TOT
END MODULE BASIC

MODULE MATRIX
 IMPLICIT NONE
 TYPE :: FACE_VEC  ! For Vertex
 	INTEGER :: C_SIZE,POINT_BC ! POINT_BC = 0 INNER NODE; = 1 HEAD BC; = 2 FLUX BC; = 3 RIVER HEAD BC; = 4 WELL
 	INTEGER :: BC_NUM  ! LINK THE NUMBER OF BCs, such as head1.bound
 	INTEGER :: CELL_NUM ! TOTAL NUMBER OF NEIGHBORING CELLS
 	INTEGER :: LU_T     ! LU_T is the number for the ILU
 	INTEGER, ALLOCATABLE :: C_INDEX(:)   ! INDEX FOR NEIGHBORING FACES
 	INTEGER :: CELL_IND(40)  ! INDEX FOR NEIGHBORING CELLS
 	REAL (KIND = 8) :: P,P1,PN,P_OLD
 	REAL (KIND = 8) :: X,Y
 	REAL (KIND = 8), ALLOCATABLE :: XYZ_P(:),COE_L(:),COE_U(:) 
 	REAL (KIND = 8) :: BZ,RES
 END TYPE FACE_VEC
 TYPE :: CELL_VEC
 	INTEGER :: POINT_SIZE,POINT_TYPE,POINT_BC  ! POINT_BC = 0 INNER NODE; = 1 HEAD BC; = 2 FLUX BC; = 3 RIVER HEAD BC; = 4 WELL
 	INTEGER :: BC_NUM  ! LINK THE NUMBER OF BCs, such as head1.bound
 	INTEGER, ALLOCATABLE :: POINT_INDEX(:)
 ! For linear matrix coefficient
 	REAL (KIND = 8) :: CELL_V,X,Y
 	REAL (KIND = 8) :: HEAD_REC
 ! For soil properties
 	INTEGER :: SOIL_UNIT   ! Determine the soil type unit (such as soil1.dat)
 	INTEGER :: SOIL_T
 	REAL (KIND = 8) :: ALPHA,M2,A,B,THETAS,THETAR,K_SS  ! K_SS is the mutiplier for the saturated Ks
 	REAL (KIND = 8) :: K_S(2,2) ! Saturated hydraulic conductivity is a tensor
 	REAL (KIND = 8) :: MTH,CTH,HTH,SS,MTHN,HTHN,KTH  ! KTH is the relative hydraulic conductivity
 	REAL (KIND = 8) :: HTH1,VX,VY
 	REAL (KIND = 8) :: HDRY,HWET
 	REAL (KIND = 8), ALLOCATABLE :: NX(:),NY(:),AREA(:)
 	REAL (KIND = 8), ALLOCATABLE :: MCF(:,:),RRNC(:,:)
 	REAL (KIND = 8), ALLOCATABLE :: FA_COE(:)
 ! For the pumping well part
 	INTEGER :: SINGULAR_FLAG
 	REAL (KIND = 8), ALLOCATABLE :: SHAPE_COE(:)
 END TYPE CELL_VEC
 TYPE (CELL_VEC), ALLOCATABLE :: CELL_COE(:)
 TYPE (FACE_VEC), ALLOCATABLE :: FACE_COE(:)
 
END MODULE MATRIX

 PROGRAM MAIN
	USE BASIC
	USE MATRIX
	IMPLICIT NONE
	INTEGER :: I,J,K,N,IK,JK,NK,KK
	INTEGER :: IKKK
	CHARACTER (LEN = 256) :: PATH
	REAL (KIND = 8) :: KTH1,DT_REP,DH_STEADY_MAX
	LOGICAL :: FILE_EXISTS
	CHARACTER (LEN = 256) :: DATE
	REAL (KIND = 8) :: START_T,END_T

	CALL cpu_time(START_T)
!-------For the Input File
	CALL getcwd(PATH)
	CALL INITIAL
	PATH = trim(PATH)//'/'
	NCYC = 0
	
	WRITE (*,*) 'PUMPING WELL LOCATION'
	DO IK = 1,CELL_TOT
		IF (CELL_COE(IK)%POINT_BC.EQ.4) THEN 
			WRITE (*,*) CELL_COE(IK)%BC_NUM,CELL_COE(IK)%X,CELL_COE(IK)%Y
		END IF
	END DO
	
	IKKK = 0
	OPEN (993,FILE = trim(PATH)//trim(NAME_FILE)//'_head.dat',status = 'unknown')
	DO WHILE (T.LT.T_LIM)
		T = T+DT
		DT = DT*DT_AMP
		NCYC = NCYC+1
		IF (MOD(NCYC,NCYC_CHECK).EQ.0) THEN 
			WRITE (*,*) 'NCYC = ',NCYC,T
		END IF
		CALL HEAD_READ
		CALL FLUX_READ
		CALL WELL_READ
		CALL RIVER_READ
		CALL RAIN_READ
		
		CALL RICHARDS
		
	!	WRITE (993,'(100F20.10)') T,(HTH(DRAW_XYZ(N)),N=1,DRAW_NUM)
		IF (OUT_TYPE.EQ.0) THEN 
			IF (MOD(NCYC,NCYC_OUT).EQ.0) THEN
		!	WRITE (993,'(3000F20.10)') T,(HTH(DRAW_XYZ(N)),N=1,DRAW_NUM)
		!	WRITE (994,'(3000F20.10)') T,(MTH(DRAW_XYZ(N)),N=1,DRAW_NUM)
				WRITE (993,'(70000F20.10)') T,(FACE_COE((DRAW_XYZ(N)))%P,N=1,DRAW_NUM)
				
			END IF
		ELSE 
			DO IK = 1,OUT_TYPE
			!	IF (T.LE.OUTPUT_VEC(IK).AND.(T+DT).GT.OUTPUT_VEC(IK)) THEN
				IF (ABS(T-OUTPUT_VEC(IK))/DT.LE.1.0E-2) THEN 
					OPEN (911,FILE = trim(PATH)//trim(NAME_FILE)//'_head_v'//CHAR(IK+48)//'.dat')
					DO N = 1,DRAW_NUM
						KK = DRAW_XYZ(N)
						WRITE (911,'(20F20.10)') CELL_COE(KK)%X,CELL_COE(KK)%Y, &
						CELL_COE(KK)%HTH,CELL_COE(KK)%VX,CELL_COE(KK)%VY,CELL_COE(KK)%CELL_V
					END DO
					CLOSE (911)
					
					OPEN (922,FILE = trim(PATH)//trim(NAME_FILE)//'_head_node'//CHAR(IK+48)//'.dat')
					DO KK = 1,FACE_TOT
						WRITE (922,'(I10,20F20.10)') FACE_COE(KK)%POINT_BC,FACE_COE(KK)%X,FACE_COE(KK)%Y,FACE_COE(KK)%P
					END DO
				END IF
 			END DO
		END IF
	END DO
	CLOSE (993)
	CALL cpu_time(END_T)
	
	
	OPEN (96,FILE = trim(NAME_FILE)//'_CPU_TIME.DAT')
	WRITE (96,*) END_T-START_T
	CLOSE (96)
	
	OPEN (95,FILE = trim(NAME_FILE)//'_OBS_XY.DAT')
	DO N = 1,DRAW_NUM
		WRITE (95,'(20F20.10)') FACE_COE((DRAW_XYZ(N)))%X,FACE_COE((DRAW_XYZ(N)))%Y
	END DO
	
	CLOSE (95)
	
	
 END PROGRAM MAIN


